# ლექცია

### ინფორმაცია, ალგორითმი.

<iframe width="560" height="315" src="https://www.youtube.com/embed/51T6HerfVso?si=n9SXzp_VdUutzKJM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

---

### ჩანაწერები

#### გამარჯობა სამყარო!

გამარჯობა, ამ ლექციაში განხილულია ინფორმაცია, მისი გადაცემისა და შენახვის სხვადასხვა ხერხები. ასევე ვიტყვით, თუ რა არის ორობითი სისტემა და რატომ გამოიყენება იგი კომპიუტერებში. ლექციის მეორე ნახევარში კი გადავალთ უშუალოდ დაპროგრამებაზე და დავწერთ ჩვენს პირველ ალგორითმს.

#### ინფორმაცია

საიდან იცის კომპიუტერმა, როგორ გამოიყურება სიმბოლო ან როგორ უნდა შეინახოს ფოტო, ვიდეო, ტექსტი? ამ კითხვაზე პასუხის გასაცემად ჯერ უნდა ვთქვათ, რა არის ინფორმაცია. კითხვაზე პასუხი დავიწყოთ ისტორიის გახსენებით.

ძველი ეგვიპტელები და მათი იეროგლიფები, წარწერები კედლებზე — ეს არის ინფორმაციის შენახვის ერთ-ერთი კარგი მაგალითი, რომელმაც, როგორც ხედავთ, დროსაც გაუძლო.

რაც შეეხება ინფორმაციის გადაცემას, შეგვიძლია გავიხსენოთ ამერიკელი ინდიელები და მათი კვამლის სიგნალები. წარმოიდგინეთ სისტემა: არის ორი ჯგუფი, რომლებიც დიდ დისტანციაზე არიან დაშორებულნი და კარგად ხედავენ მხოლოდ კვამლს. მათ ეს გამოიყენეს და მოიფიქრეს, სიგნალი გადაეცათ კოცონის კვამლში წყვეტების გაკეთბით.

შესაბამისად, წყვეტების სხვადასხვა რაოდენობა სხვადასხვა შინაარსობრივ მნიშვნელობას ატარებდა. პირობითად, ორი წყვეტა შეიძლებოდა ყოფილიყო განგაშის სიგნალი, ხოლო სამი წყვეტა — უბრალოდ ყურადღებისკენ მოწოდება ან მსგავსი რამ.

შემდეგ ვისწავლეთ ინფორმაციის ფურცელზე დატანა და გამოვიგონეთ გრაგნილები, რომლებიც თავის თავში ორივე — ინფორმაციის გადაცემის და შენახვის ფუნქციას ითავსებდნენ. გრაგნილები განვითარდა და მივიღეთ წიგნები.

წიგნებისთვის ავაშენეთ ბიბლიოთეკები, რომლებიც არის მრავალსართულიანი შენობები, სადაც ათასობით წიგნი ინახება. წარმოიდგინეთ, უზარმაზარი რაოდენობის ინფორმაციაა, რომელიც დღეს ჩვენ შეგვიძლია ჯიბით ვატაროთ ჩვენი USB მეხსიერების ჩიპების დახმარებით.


#### ელექტროენერგია & მორზე

ამ უზარმაზარ ევოლუციაში ყველაზე დიდი წვლილი აქვს შეტანილი ელექტროენერგიას. როდესაც ვისწავლეთ ელექტროენერგიის ეფექტურად გამოყენება, მაშინვე გაჩნდა ბევრი სისტემა და მექანიზმი, თუ როგორ შეიძლება ინფორმაციის გადაცემა და მიღება მის საშუალებით.

ერთ-ერთი ყველაზე ცნობილი საშუალება არის მორზეს ანბანი.

ალბათ გაგიგიათ — ეს არის სისტემა, სადაც ლათინურ ასოებსა და სიმბოლოებს შეუსაბამეს ელექტრული სიგნალების კომბინაციები. წერტილი არის მოკლე ელექტრული სიგნალი, ხოლო ტირე — გრძელი.

ქვემოთ მოცემულია სიტყვა “hello” და მისი მორზეს კოდით წარმოდგენა. მოდი გავარჩიოთ მაგალითი, რომ უკეთ გავიგოთ როგორ მუშაობს მორზეს კოდის სისტემა.

დავუშვათ, გვაქვს ორი სამხედრო პუნქტი, რომლებიც განლაგებულია ორ ქალაქში და მათ შორის გავლებულია ელექტრული სადენი. გამგზავნ ქალაქში დევს აპარატი, რომელსაც აქვს ღილაკი, რომელზე დაჭერითაც ვუშვებთ ელექტროენერგიას კაბელში.

თუ დავაჭერთ ღილაკს ცოტა ხნით — წავა მოკლე სიგნალი; ხოლო დიდი ხნით — გრძელი. ბუნებრივია, მიმღებ პუნქტში არსებობს მიმღები, რომელიც იღებს ამ სიგნალებს და ქაღალდზე დაიტანს.

შემდეგ ამას ადამიანი უყურებს და თარგმნის, მაგალითად: თუ სიგნალი მოკლეა — ეს არის წერტილი, თუ გრძელია — ტირე. მაგრამ წარმოიდგინეთ სიტუაცია, როცა გვაქვს ბუნდოვანი სიგნალი — არც ძალიან გრძელი და არც ძალიან მოკლე. ასეთ დროს ადამიანი კონტექსტიდან გამომდინარე წყვეტს, იყო ეს წერტილი თუ ტირე.


#### ინფორმაციის გაციფრულება

კომპიუტერს ასეთი კონტექსტური ანალიზის უნარი არ გააჩნია. კომპიუტერი ელექტრულ დონეზე მხოლოდ აბსოლუტური სიზუსტის მქონე ბრძანებებს ასრულებს. ამიტომ უნდა გადავიდეთ იმ სისტემაზე, რომელიც კომპიუტერისთვის არის სრულიად გასაგები — ორობით სისტემაზე.

მოდით განვიხილოთ მაგალითი Minecraft-იდან. იქ გვაქვს 6 ნათურა.
5 მათგანში მიდის დენი, ერთი კი გამორთულია. ჩვენი მიზანია დავაკვირდეთ მხოლოდ ორ მდგომარეობას — ანთებულია თუ არა. ანუ — არის დენი თუ არა.

ეს არის ზუსტად ორობითი მსჯელობა. ორობით სისტემაში გვაქვს მხოლოდ ორი მდგომარეობა — “კი” ან “არა”, “ჩართული” ან “გამორთული”, “ერთი” ან “ნული”.

ამ ერთი შეხედვით მარტივი სისტემითაც კი შეგვიძლია ნებისმიერი ტიპის მონაცემები წარმოვადგინოთ. მოდით ავიღოთ რიცხვი 29.

რიცხვი 29 შეიძლება ნიშნავდეს ტემპერატურას, ფასი, ან რაიმე რიგითობას.
ასევე შეგვიძლია თითოეულ ქართულ ასოს მივანიჭოთ რიგითობის შესაბამისი რიცხვი: ა = 0, ბ = 1, გ = 2 და ა.შ.

მაგალითად, სიტყვა “ხაჭაპური” ჩვენს სისტემაში გადაიქცევა შემთხვევით რიცხვთა მიმდევრობაში, მაგრამ სინამდვილეში ეს არის აზრიანი მონაცემი.

#### ორობითი სისტემა

მხოლოდ ერთი ნაბიჯი დაგვრჩა — ამ რიცხვების ორობით სისტემაში გადაყვანა.

ათი არის ჩვეულებრივი ათობითი სისტემა, რომელსაც ყოველდღიურად ვიყენებთ. მას აქვს 10 უნიკალური სიმბოლო — 0-დან 9-მდე. როდესაც ვთვლით 9-ის შემდეგ მოდის 10, ანუ გვჭირდება ორი სიმბოლო.

იგივე ხდება ორობითში, ოღონდ ორი სიმბოლოთი — 0 და 1.

რიცხვი 251 ორობითში რომ გადავიყვანოთ, ვნახავთ რომ იგი შედგება სხვადასხვა ხარისხების ჯამიდან — 128 + 64 + 32 + 16 + 8 + 2 + 1.

დავუბრუნდეთ სიტყვა “ხაჭაპურს”. თუ თითოეულ ასოს შევუსაბამებთ შესაბამის რიცხვს და შემდეგ ეს რიცხვები გადავიყვანთ ორობითში, მივიღებთ ასოების ორობით წარმოდგენას.

#### სტანდარტული კოდის გამოყენება

მაგრამ რადგან სხვადასხვა ასო შეიძლება სხვადასხვა სიგრძის ორობით რიცხვით გამოვისახოს, საჭიროა სტანდარტიზაცია — მაგალითად, ყველა ასოს ჰქონდეს 5 ბიტიანი კოდი.

ბიტი არის ინფორმაციის ყველაზე მცირე ერთეული — ერთი ორობითი ციფრი (0 ან 1). ბაიტი კი შედგება 8 ბიტისგან.

ბაიტი საშუალებას გვაძლევს წარმოვადგინოთ 256 განსხვავებული სიმბოლო.

ASCII სტანდარტი შეიცავს 256 სიმბოლოს, მაგრამ ქართულს, იაპონურს, ემოჯის — ვერ.

ამ პრობლემის გადასაჭრელად შეიქმნა Unicode — უნივერსალური კოდირება, რომელიც მოიცავს ყველა ენას.

ჩვენ უკვე ვიცით როგორ შევინახოთ ტექსტი, სიმბოლო, რიცხვი.

#### ფერების წარმოდგენა (RGB)

ფერის შემთხვევაში ვხმარობთ RGB-ს — სამი ფერის შერევით ვქმნით სხვა ნებისმიერ ფერს: წითელი, მწვანე, ლურჯი. თითოეული ფერი შეიძლება გამოვსახოთ 1 ბაიტით (0–255).

ერთად აღებული RGB ქმნის ერთ ფერს. პიქსელი კი — სამ ფერს. ფოტო შედგება პიქსელებისგან. ვიდეო — ფოტოების სწრაფი ცვლა.


#### ალგორითმი

ინფორმაცია არა მხოლოდ ინახება და გადაეცემა, არამედ მუშავდება — სწორედ ამიტომ გვჭირდება ალგორითმები და პროგრამირება.

#### კარლოს სამყარო

მაგალითად, კარლო — რობოტი, რომელსაც შეუძლია უჯრებში გადაადგილება, აგურების აღება და დადება. მას ვაწვდით ალგორითმს — ქმედებების მიმდევრობას, რაც პრობლემის გადაჭრას გულისხმობს.

მოკლედ, პროგრამა არის ბრძანებების ნაკრები, რომელიც კონკრეტულ შედეგს იძლევა.
ამის მაგალითები: for loop (n-ჯერ გამეორება), while loop (სანამ პირობა კმაყოფილდება), if/else (თუ… მაშინ… თუ არა… მაშინ…).

მაგალითად, თუ გვინდა კარლომ ყველა კუთხეში დადოს აგური, გამოვიყენებთ for ციკლს.
თუ გვინდა მან იმოძრაოს სანამ წინ არის ადგილი — while.
თუ გვსურს, რომ თუ აგური დახვდა აიღოს, თუ არა — დადოს, მაშინ if/else.

ბოლოს, გავაერთიანებთ ყველა ცოდნას და გადავჭრით რთულ პრობლემას — კოშკების დანგრევა, აგურების შეგროვება, დაბლა ჩამოტანა, და უკან დაბრუნება.

#### დასკვნა

ჩვენ პრობლემა დავყავით ნაწილებად, დავწერეთ ალგორითმი, დავყავით კომპონენტებად და საბოლოოდ პრობლემაც გადაიჭრა. ეს არის ალგორითმული აზროვნება და პროგრამირება — როცა პრობლემას ვაშლით ნაწილებად და ვწერთ კონკრეტულ, ელეგანტურ კოდს.